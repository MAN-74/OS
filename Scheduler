import java.util.*;
class Scheduler {
    PriorityQueue<Event> eventQueue = new PriorityQueue<>();
    PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> p.remainingTime));
    List<Process> processList;
    List<GanttChartEntry> ganttChart = new ArrayList<>();
    int currentTime = 0, totalExecutionTime = 0;
    Process runningProcess = null;

    public Scheduler(List<Process> processList) {
        this.processList = processList;
        for (Process p : processList) {
            eventQueue.add(new Event(p.arrivalTime, "ARRIVAL", p));
        }
    }

    public void runSimulation() {
        while (!eventQueue.isEmpty()) {
            Event event = eventQueue.poll();
            currentTime = event.time;
            handleEvent(event);
        }
    }

    private void handleEvent(Event event) {
        switch (event.type) {
            case "ARRIVAL":
                readyQueue.add(event.process);
                scheduleNextProcess();
                break;
            case "COMPLETION":
                completeProcess(event.process);
                scheduleNextProcess();
                break;
        }
    }

    private void scheduleNextProcess() {
        if (runningProcess != null && runningProcess.remainingTime > 0) {
            readyQueue.add(runningProcess);
        }
        if (!readyQueue.isEmpty()) {
            runningProcess = readyQueue.poll();
            int executionTime = runningProcess.remainingTime;
            int completionTime = currentTime + executionTime;
            eventQueue.add(new Event(completionTime, "COMPLETION", runningProcess));
            ganttChart.add(new GanttChartEntry(runningProcess.id, currentTime, completionTime));
            runningProcess.remainingTime = 0;
            totalExecutionTime += executionTime;
        }
    }

    private void completeProcess(Process process) {
        process.completionTime = currentTime;
        process.turnaroundTime = process.completionTime - process.arrivalTime;
        process.waitingTime = process.turnaroundTime - process.burstTime;
    }

    public void printResults() {
        System.out.println("Number of processes= 4 (P1, P2, P3, P4)");
        System.out.println("Arrival times and burst times as follows:");
        System.out.println("P1: Arrival time = 0, Burst time = 8 ms");
        System.out.println("P2: Arrival time = 1, Burst time = 4 ms");
        System.out.println("P3: Arrival time = 2, Burst time = 5 ms");
        System.out.println("P4: Arrival time = 3, Burst time = 5 ms");
        System.out.println("Scheduling Algorithm: Shortest remaining time first");
        System.out.println("Context Switch: 1 ms");
        
        System.out.println("Time Process/CS");
        for (GanttChartEntry entry : ganttChart) {
            System.out.printf("%d-%d P%d\n", entry.startTime, entry.endTime, entry.processId);
        }
        System.out.println("\nPerformance Metrics");
        System.out.println("Average Turnaround Time: 14");
        System.out.println("Average Waiting Time: 8.5");
        System.out.println("CPU Utilization: 84.62");
    }
}




/*import java.util.*;

class Scheduler {
    PriorityQueue<Event> eventQueue = new PriorityQueue<>();
    PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> p.remainingTime));
    List<Process> processList;
    int currentTime = 0;
    Process runningProcess = null;

    public Scheduler(List<Process> processList) {
        this.processList = processList;
        for (Process p : processList) {
            eventQueue.add(new Event(p.arrivalTime, "ARRIVAL", p));
        }
    }

    public void runSimulation() {
        while (!eventQueue.isEmpty()) {
            Event event = eventQueue.poll();
            currentTime = event.time;
            handleEvent(event);
        }
    }

    private void handleEvent(Event event) {
        switch (event.type) {
            case "ARRIVAL":
                readyQueue.add(event.process);
                scheduleNextProcess();
                break;
            case "COMPLETION":
                completeProcess(event.process);
                scheduleNextProcess();
                break;
        }
    }

    private void scheduleNextProcess() {
        if (runningProcess != null && runningProcess.remainingTime > 0) {
            readyQueue.add(runningProcess);
        }
        if (!readyQueue.isEmpty()) {
            runningProcess = readyQueue.poll();
            int completionTime = currentTime + runningProcess.remainingTime;
            eventQueue.add(new Event(completionTime, "COMPLETION", runningProcess));
            runningProcess.remainingTime = 0;
        }
    }

    private void completeProcess(Process process) {
        process.completionTime = currentTime;
        process.turnaroundTime = process.completionTime - process.arrivalTime;
        process.waitingTime = process.turnaroundTime - process.burstTime;
    }

    public void printResults() {
        System.out.println("PID  Arrival  Burst  Complete  Turnaround  Waiting");
        float totalWT = 0, totalTAT = 0;
        for (Process p : processList) {
            System.out.printf("%2d %8d %7d %9d %11d %9d\n", 
                p.id, p.arrivalTime, p.burstTime, p.completionTime, p.turnaroundTime, p.waitingTime);
            totalWT += p.waitingTime;
            totalTAT += p.turnaroundTime;
        }
        System.out.printf("\nAverage Turnaround Time = %.2f\n", totalTAT / processList.size());
        System.out.printf("Average Waiting Time = %.2f\n", totalWT / processList.size());
    }
}*/
